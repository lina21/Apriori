import math
import collections
import copy
import time

dataset = []

def GetData():
        global dataset
        dataset = []
        file = open("data-2016.csv", "r")
        av = file.readlines()
        file.close()
        for i in range(len(av)):
                dataset.append([])
                string = av[i].split()
                for j in range(len(string)):
                        dataset[len(dataset)-1].append(string[j])

def GetUniqueCourses():
        courses = dict()
        for i in range(len(dataset)):
                j = 2
                while j < len(dataset[i]):
                        if dataset[i][j] not in courses.keys():
                                courses[dataset[i][j]] = copy.deepcopy(dataset[i][j+1])
                        j += 5
        return courses

def GetTransactions():
        trans = []
        for i in range(len(dataset)):
                j = 2
                courses = []
                while j < len(dataset[i]):
                        if (dataset[i][j] not in courses):
                                courses.append(int(dataset[i][j]))
                        j += 5
                trans.append(courses)
        return trans

def GetCoursesCodes():
    return list(map(int, GetUniqueCourses().keys()))

def SupportCount(transactions, itemset):
        support_count = 0
        for i in range(len(transactions)):
                matches = []
                for j in range(len(transactions[i])):
                        if (transactions[i][j] in itemset) and (transactions[i][j] not in matches):
                                matches.append(transactions[i][j])
                                if matches == len(itemset):
                                        break
                if len(matches) == len(itemset):
                        support_count += 1
        return support_count

def Support(transactions, itemset):
        return SupportCount(transactions, itemset)/len(transactions)

def Union(itemset1, itemset2):
    return list(sorted(set().union(itemset1, itemset2)))

def Generate(lists):
    response = []
    if len(lists) > 1:
        index = 0
        while index < len(lists) - 1:
            first = lists[index]
            index2 = index + 1
            while index2 < len(lists):
                second = lists[index2]
                if (first[0:len(first)-1] == second[0:len(second)-1]):
                    response.append(Union(first, second))

                index2 += 1

            index += 1

    return response

def Apriori(transactions, min_support, k):
    lists = []
    iter = 1
    courses = sorted(GetCoursesCodes())
    for i in range(len(courses)):
        if Support(transactions, [courses[i]]) >= min_support:
            lists.append([courses[i]])
    while (len(lists) != 0) or (iter < k):
        candidates = Generate(lists)
        for candidate in candidates:
            supp = Support(transactions, candidate)
            if supp < min_support:
                candidates.remove(candidate)
            #now we have only frequent candidates
            iter += 1
        lists = candidates

    return lists


def AddOne(n, k, set):
    i = len(set) - 1
    b = False
    while b == False and i >= 0:
        if (set[i] < n - k + i + 1):
            set[i] += 1
            b = True
            break
        else:
            i -= 1
    if i == -1:
        set = []
    elif (i <= k-2):
        set[i+1] = set[i] + 1
        for j in range(i + 2, k):
            set[j] = set[j-1] + 1

    return set

#Generates all possible combinations
def CoursesCombinations(n, k):
    i = 0
    comb = list(range(1, k+1))
    kCourseCombinations = []
    while len(comb) != 0:
        i += 1
        kCourseCombinations.append(copy.deepcopy(comb))
        comb = AddOne(n, k, comb)
    return kCourseCombinations

#My implementation to get k-sized combinations of courses 'set' with minumum support 'minSupport'
def MinSupportCoursesCombinations(transactions, set, k, minSupport):
        supports = []
        for i in range(len(set)):
            supports.append(Support(transactions, [set[i]]))
        minSupportIndeces = [i for i, x in enumerate(supports) if x >= minSupport]
        combs = CoursesCombinations(len(minSupportIndeces), k)
        res = []
        for i in range(len(combs)):
            courses_codes = []
            for j in range(k):
                courses_codes.append(set[minSupportIndeces[combs[i][j]-1]])
            if Support(transactions, courses_codes) >= minSupport:
                res.append(courses_codes)
        return res

def main():
        global dataset
        GetData()
        #For Task 11
        now1 = time.time()
        combs = MinSupportCoursesCombinations(GetTransactions(), GetCoursesCodes(), 2, 0.1)
        now2 = time.time()
        print(now2-now1, len(combs))
        now1 = time.time()
        combs = MinSupportCoursesCombinations(GetTransactions(), GetCoursesCodes(), 3, 0.1)
        now2 = time.time()
        print(now2-now1, len(combs))
        #For Task 17
        now1 = time.time()
        combs = Apriori(GetTransactions(), 0.1, 2)
        now2 = time.time()
        print(now2-now1, len(combs))
        now1 = time.time()
        Apriori(GetTransactions(), 0.1, 3)
        now2 = time.time()
        print(now2-now1, len(combs))



if __name__ == "__main__":
           main()
